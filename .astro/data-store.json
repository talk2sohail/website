[["Map",1,2,9,10,95,96],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.15.8","content-config-digest","3c78cacb0c26be6f","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://mdsohail.dev\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"server\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":false,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\",\"entrypoint\":\"astro/assets/endpoint/dev\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"prism\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false},\"session\":{\"driver\":\"fs-lite\",\"options\":{\"base\":\"/Users/mdsohail/Downloads/code/mdsohaildev/node_modules/.astro/sessions\"}}}","blog",["Map",11,12,70,71],"a-developer-guide-to-mmap",{"id":11,"data":13,"body":23,"filePath":24,"assetImports":25,"digest":29,"rendered":30,"legacyId":69},{"title":14,"description":15,"author":16,"publishDate":17,"tags":18},"A Developer's Guide to Memory-Mapped Files (mmap)","Exploring the power and pitfalls of memory-mapped file I/O.","Md Sohail",["Date","2025-12-10T00:00:00.000Z"],[19,20,21,22],"systems-programming","mmap","performance","golang","In systems programming, there's a technique that feels both like a powerful shortcut and a hidden trap: [mmap2](https://man7.org/linux/man-pages/man2/mmap.2.html) system call., or memory-mapped file I/O. If you're accustomed to the traditional routine of managing buffers and `read()` and `write()` system calls, mmap can seem like a revelation. It allows you to treat a file on disk as if it were a part of your program's memory.\n\nThis post explores that idea: the performance benefits of treating your hard drive like RAM, and the subtle complexities that have challenged even experienced database developers.\n\n## The Core Concept: How It Works\n\nWith traditional file I/O, you ask the operating system (OS) to read data from a disk and copy it into a buffer in your program's memory. With mmap, you ask the OS to map the file's contents directly into your program’s virtual address space. The result is a pointer (or a slice in Go) that you can use to access the file's data as if it were an in-memory array.\n\n\n**![](./how-mmap-works.png)**\n\u003Csmall>*(Image Prompt: A diagram showing a large file on a hard disk on the left, and a block of Virtual Memory addresses on the right. Dotted lines connect specific chunks of the disk file to specific addresses in memory. A label points to the memory saying \"To the code, this looks like RAM,\" while a label points to the connection saying \"OS loads pages lazily.\")*\u003C/small>\n\n### Code Comparison: Standard I/O vs. mmap\n\nThe difference in code makes the \"magic\" of mmap clear.\n\n**Standard I/O**\n\nThis approach requires you to manage buffers and file offsets manually.\n\n```go\n// Traditional File Reading\nfile, err := os.Open(\"large_data.bin\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer file.Close()\n\n// We have to manage a buffer in user-space\nbuf := make([]byte, 1024)\nfor {\n    n, err := file.Read(buf)\n    if err != nil && err != io.EOF {\n        log.Fatal(err)\n    }\n    if n == 0 {\n        break\n    }\n    // Process buf[:n]...\n}\n```\n\n**mmap**\n\nWith mmap, the file's data is accessed like a variable in your application, with no explicit read calls. The following example uses the `gommap` library, a Go wrapper for the mmap system call.\n\n```go\n// Using launchpad.net/gommap\nfile, _ := os.Open(\"large_data.bin\", os.O_RDONLY, 0)\n// Map the file directly into memory\nmmap, _ := gommap.Map(file.Fd(), gommap.PROT_READ, gommap.MAP_PRIVATE)\n\n// Access file contents like a normal slice!\n// No seek(), no read(), just array indexing.\nend := bytes.Index(mmap, []byte(\"\\n\"))\nprintln(string(mmap[:end]))\n```\n\nThe OS performs a \"lazy\" load. It reserves the address space, but only loads a page of data from the disk when your program accesses a memory address within that page. This triggers a \"page fault,\" a hardware interrupt that signals the OS to fetch the required data. This process is transparent to your application.\n\n## The Advantage: Zero-Copy I/O\n\nThe primary benefit of mmap is **Zero-Copy I/O**. In traditional `read()`, data is copied from the disk to the kernel's page cache, and then from the page cache to your program's user-space buffer. The second copy is redundant. mmap allows your program to access the kernel's page cache directly, eliminating this extra copy and reducing CPU overhead.\n\n\n\n\n\n**![](./zero-copy.png)**\n\u003Csmall>*(Image Prompt: A split comparison. Top (Standard): A \"Bucket Brigade\" where the Kernel hands data to a User Buffer (Copy). Bottom (mmap): The User accesses the Kernel's bucket directly. Caption: \"mmap avoids the redundant copy to user space.\")*\u003C/small>\n\n## The Hidden Perils\n\nHowever, mmap is not a \"free lunch.\" The abstraction that makes it so convenient also introduces complexities.\n\n### 1. The Illusion of Memory and I/O Stalls\n\nWhile your code appears to be accessing memory, which is typically a nanosecond-scale operation, a page fault can cause your thread to block for milliseconds while the OS fetches the data from the much slower disk. This is especially problematic for schedulers that are not designed to distinguish between a page fault and a CPU-bound operation, potentially leading to under-utilization of system resources.\n\n\n\n\n**![](./page-fault.png)**\n\u003Csmall>*(Image Prompt: A timeline graph. The CPU line is active (green), then hits a red block \"Page Fault.\" The line goes flat while \"Disk I/O\" spikes. Caption: \"Your thread freezes unpredictably when touching a memory address.\")*\u003C/small>\n\n### 2. The Danger of SIGBUS and Difficult Error Handling\n\nWith standard I/O, a disk failure or a file truncation results in an error that your program can handle gracefully. With mmap, if you access an index that is beyond the file's current size (perhaps because another process truncated it), the hardware raises an exception, and the OS sends your program a `SIGBUS` or `SIGSEGV` signal, causing it to crash immediately. This makes error handling significantly more complex, often requiring the implementation of signal handlers, which are notoriously difficult to write correctly.\n\nThis isn't just a theoretical problem. **MongoDB's original storage engine (MMAPv1)** was built on mmap and faced challenges with space wastage and complexity, eventually leading to its replacement.\n\n### 3. Performance on Fast Drives (NVMe)\n\nCounter-intuitively, mmap can be slower than standard I/O on very fast NVMe SSDs. The overhead of managing page tables and handling \"TLB shootdowns\" (the process of invalidating cached memory address translations across multiple CPU cores) can become a bottleneck in high-throughput scenarios. This is a key reason why high-performance databases like **SingleStore** and **InfluxDB** have moved away from mmap, citing issues with I/O spikes and contention.\n\n## Conclusion: When to Use mmap\n\nmmap is a powerful, specialized tool. It's a good choice when:\n\n*   You have large files and need random access.\n*   Multiple processes need to read the same file, as they can share the same physical memory pages.\n*   Your workload is read-only and the data fits comfortably in RAM.\n\nIt's probably *not* the right choice when:\n\n*   You need strict transactional safety, as in a database.\n*   You require the highest possible throughput on fast SSDs.\n*   You cannot tolerate the risk of unpredictable crashes due to I/O errors.\n\nmmap offers a fascinating look into the abstractions that operating systems provide. It blurs the line between files and memory, but like any powerful tool, it requires a deep understanding of its underlying mechanics to be used effectively.\n\n## References\n\n*   A good wrapper for the mmap written in Go [here.](https://labix.org/gommap)\n*   [This](https://github.com/buildbarn/bb-storage/blob/c346ca331930f1bc5e4f9bde75de96ee3e6c8a9c/pkg/blockdevice/memory_mapped_block_device_unix.go#L49) is a piece of open-source Go code that uses a page-fault handler to deal with any IO error that may arise from memory mapping. The Debug packages `SetPanicOnFault` function is used.\n*   I’m still reading this paper by Andy Pavlo & other researchers on reasons to avoid MMap in your DBMS check it out [Youtube](https://www.youtube.com/watch?v=1BRGU_AS25c) and [Paper.](https://www.cidrdb.org/cidr2022/papers/p13-crotty.pdf)","src/content/blog/a-developer-guide-to-mmap.md",[26,27,28],"./how-mmap-works.png","./zero-copy.png","./page-fault.png","c059f1baab9773e9",{"html":31,"metadata":32},"\u003Cp>In systems programming, there’s a technique that feels both like a powerful shortcut and a hidden trap: \u003Ca href=\"https://man7.org/linux/man-pages/man2/mmap.2.html\">mmap2\u003C/a> system call., or memory-mapped file I/O. If you’re accustomed to the traditional routine of managing buffers and \u003Ccode>read()\u003C/code> and \u003Ccode>write()\u003C/code> system calls, mmap can seem like a revelation. It allows you to treat a file on disk as if it were a part of your program’s memory.\u003C/p>\n\u003Cp>This post explores that idea: the performance benefits of treating your hard drive like RAM, and the subtle complexities that have challenged even experienced database developers.\u003C/p>\n\u003Ch2 id=\"the-core-concept-how-it-works\">The Core Concept: How It Works\u003C/h2>\n\u003Cp>With traditional file I/O, you ask the operating system (OS) to read data from a disk and copy it into a buffer in your program’s memory. With mmap, you ask the OS to map the file’s contents directly into your program’s virtual address space. The result is a pointer (or a slice in Go) that you can use to access the file’s data as if it were an in-memory array.\u003C/p>\n\u003Cp>\u003Cstrong>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;./how-mmap-works.png&#x22;,&#x22;alt&#x22;:&#x22;&#x22;,&#x22;index&#x22;:0}\">\u003C/strong>\n\u003Csmall>\u003Cem>(Image Prompt: A diagram showing a large file on a hard disk on the left, and a block of Virtual Memory addresses on the right. Dotted lines connect specific chunks of the disk file to specific addresses in memory. A label points to the memory saying “To the code, this looks like RAM,” while a label points to the connection saying “OS loads pages lazily.”)\u003C/em>\u003C/small>\u003C/p>\n\u003Ch3 id=\"code-comparison-standard-io-vs-mmap\">Code Comparison: Standard I/O vs. mmap\u003C/h3>\n\u003Cp>The difference in code makes the “magic” of mmap clear.\u003C/p>\n\u003Cp>\u003Cstrong>Standard I/O\u003C/strong>\u003C/p>\n\u003Cp>This approach requires you to manage buffers and file offsets manually.\u003C/p>\n\u003Cpre class=\"language-go\" data-language=\"go\">\u003Ccode is:raw=\"\" class=\"language-go\">\u003Cspan class=\"token comment\">// Traditional File Reading\u003C/span>\nfile\u003Cspan class=\"token punctuation\">,\u003C/span> err \u003Cspan class=\"token operator\">:=\u003C/span> os\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">Open\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token string\">\"large_data.bin\"\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\n\u003Cspan class=\"token keyword\">if\u003C/span> err \u003Cspan class=\"token operator\">!=\u003C/span> \u003Cspan class=\"token boolean\">nil\u003C/span> \u003Cspan class=\"token punctuation\">{\u003C/span>\n    log\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">Fatal\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>err\u003Cspan class=\"token punctuation\">)\u003C/span>\n\u003Cspan class=\"token punctuation\">}\u003C/span>\n\u003Cspan class=\"token keyword\">defer\u003C/span> file\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">Close\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\n\n\u003Cspan class=\"token comment\">// We have to manage a buffer in user-space\u003C/span>\nbuf \u003Cspan class=\"token operator\">:=\u003C/span> \u003Cspan class=\"token function\">make\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token punctuation\">[\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\u003Cspan class=\"token builtin\">byte\u003C/span>\u003Cspan class=\"token punctuation\">,\u003C/span> \u003Cspan class=\"token number\">1024\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\n\u003Cspan class=\"token keyword\">for\u003C/span> \u003Cspan class=\"token punctuation\">{\u003C/span>\n    n\u003Cspan class=\"token punctuation\">,\u003C/span> err \u003Cspan class=\"token operator\">:=\u003C/span> file\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">Read\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>buf\u003Cspan class=\"token punctuation\">)\u003C/span>\n    \u003Cspan class=\"token keyword\">if\u003C/span> err \u003Cspan class=\"token operator\">!=\u003C/span> \u003Cspan class=\"token boolean\">nil\u003C/span> \u003Cspan class=\"token operator\">&#x26;&#x26;\u003C/span> err \u003Cspan class=\"token operator\">!=\u003C/span> io\u003Cspan class=\"token punctuation\">.\u003C/span>EOF \u003Cspan class=\"token punctuation\">{\u003C/span>\n        log\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">Fatal\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>err\u003Cspan class=\"token punctuation\">)\u003C/span>\n    \u003Cspan class=\"token punctuation\">}\u003C/span>\n    \u003Cspan class=\"token keyword\">if\u003C/span> n \u003Cspan class=\"token operator\">==\u003C/span> \u003Cspan class=\"token number\">0\u003C/span> \u003Cspan class=\"token punctuation\">{\u003C/span>\n        \u003Cspan class=\"token keyword\">break\u003C/span>\n    \u003Cspan class=\"token punctuation\">}\u003C/span>\n    \u003Cspan class=\"token comment\">// Process buf[:n]...\u003C/span>\n\u003Cspan class=\"token punctuation\">}\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Cstrong>mmap\u003C/strong>\u003C/p>\n\u003Cp>With mmap, the file’s data is accessed like a variable in your application, with no explicit read calls. The following example uses the \u003Ccode>gommap\u003C/code> library, a Go wrapper for the mmap system call.\u003C/p>\n\u003Cpre class=\"language-go\" data-language=\"go\">\u003Ccode is:raw=\"\" class=\"language-go\">\u003Cspan class=\"token comment\">// Using launchpad.net/gommap\u003C/span>\nfile\u003Cspan class=\"token punctuation\">,\u003C/span> \u003Cspan class=\"token boolean\">_\u003C/span> \u003Cspan class=\"token operator\">:=\u003C/span> os\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">Open\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token string\">\"large_data.bin\"\u003C/span>\u003Cspan class=\"token punctuation\">,\u003C/span> os\u003Cspan class=\"token punctuation\">.\u003C/span>O_RDONLY\u003Cspan class=\"token punctuation\">,\u003C/span> \u003Cspan class=\"token number\">0\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\n\u003Cspan class=\"token comment\">// Map the file directly into memory\u003C/span>\nmmap\u003Cspan class=\"token punctuation\">,\u003C/span> \u003Cspan class=\"token boolean\">_\u003C/span> \u003Cspan class=\"token operator\">:=\u003C/span> gommap\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">Map\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>file\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">Fd\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">,\u003C/span> gommap\u003Cspan class=\"token punctuation\">.\u003C/span>PROT_READ\u003Cspan class=\"token punctuation\">,\u003C/span> gommap\u003Cspan class=\"token punctuation\">.\u003C/span>MAP_PRIVATE\u003Cspan class=\"token punctuation\">)\u003C/span>\n\n\u003Cspan class=\"token comment\">// Access file contents like a normal slice!\u003C/span>\n\u003Cspan class=\"token comment\">// No seek(), no read(), just array indexing.\u003C/span>\nend \u003Cspan class=\"token operator\">:=\u003C/span> bytes\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">Index\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>mmap\u003Cspan class=\"token punctuation\">,\u003C/span> \u003Cspan class=\"token punctuation\">[\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\u003Cspan class=\"token function\">byte\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token string\">\"\\n\"\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\n\u003Cspan class=\"token function\">println\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token function\">string\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>mmap\u003Cspan class=\"token punctuation\">[\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>end\u003Cspan class=\"token punctuation\">]\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>The OS performs a “lazy” load. It reserves the address space, but only loads a page of data from the disk when your program accesses a memory address within that page. This triggers a “page fault,” a hardware interrupt that signals the OS to fetch the required data. This process is transparent to your application.\u003C/p>\n\u003Ch2 id=\"the-advantage-zero-copy-io\">The Advantage: Zero-Copy I/O\u003C/h2>\n\u003Cp>The primary benefit of mmap is \u003Cstrong>Zero-Copy I/O\u003C/strong>. In traditional \u003Ccode>read()\u003C/code>, data is copied from the disk to the kernel’s page cache, and then from the page cache to your program’s user-space buffer. The second copy is redundant. mmap allows your program to access the kernel’s page cache directly, eliminating this extra copy and reducing CPU overhead.\u003C/p>\n\u003Cp>\u003Cstrong>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;./zero-copy.png&#x22;,&#x22;alt&#x22;:&#x22;&#x22;,&#x22;index&#x22;:0}\">\u003C/strong>\n\u003Csmall>\u003Cem>(Image Prompt: A split comparison. Top (Standard): A “Bucket Brigade” where the Kernel hands data to a User Buffer (Copy). Bottom (mmap): The User accesses the Kernel’s bucket directly. Caption: “mmap avoids the redundant copy to user space.”)\u003C/em>\u003C/small>\u003C/p>\n\u003Ch2 id=\"the-hidden-perils\">The Hidden Perils\u003C/h2>\n\u003Cp>However, mmap is not a “free lunch.” The abstraction that makes it so convenient also introduces complexities.\u003C/p>\n\u003Ch3 id=\"1-the-illusion-of-memory-and-io-stalls\">1. The Illusion of Memory and I/O Stalls\u003C/h3>\n\u003Cp>While your code appears to be accessing memory, which is typically a nanosecond-scale operation, a page fault can cause your thread to block for milliseconds while the OS fetches the data from the much slower disk. This is especially problematic for schedulers that are not designed to distinguish between a page fault and a CPU-bound operation, potentially leading to under-utilization of system resources.\u003C/p>\n\u003Cp>\u003Cstrong>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;./page-fault.png&#x22;,&#x22;alt&#x22;:&#x22;&#x22;,&#x22;index&#x22;:0}\">\u003C/strong>\n\u003Csmall>\u003Cem>(Image Prompt: A timeline graph. The CPU line is active (green), then hits a red block “Page Fault.” The line goes flat while “Disk I/O” spikes. Caption: “Your thread freezes unpredictably when touching a memory address.”)\u003C/em>\u003C/small>\u003C/p>\n\u003Ch3 id=\"2-the-danger-of-sigbus-and-difficult-error-handling\">2. The Danger of SIGBUS and Difficult Error Handling\u003C/h3>\n\u003Cp>With standard I/O, a disk failure or a file truncation results in an error that your program can handle gracefully. With mmap, if you access an index that is beyond the file’s current size (perhaps because another process truncated it), the hardware raises an exception, and the OS sends your program a \u003Ccode>SIGBUS\u003C/code> or \u003Ccode>SIGSEGV\u003C/code> signal, causing it to crash immediately. This makes error handling significantly more complex, often requiring the implementation of signal handlers, which are notoriously difficult to write correctly.\u003C/p>\n\u003Cp>This isn’t just a theoretical problem. \u003Cstrong>MongoDB’s original storage engine (MMAPv1)\u003C/strong> was built on mmap and faced challenges with space wastage and complexity, eventually leading to its replacement.\u003C/p>\n\u003Ch3 id=\"3-performance-on-fast-drives-nvme\">3. Performance on Fast Drives (NVMe)\u003C/h3>\n\u003Cp>Counter-intuitively, mmap can be slower than standard I/O on very fast NVMe SSDs. The overhead of managing page tables and handling “TLB shootdowns” (the process of invalidating cached memory address translations across multiple CPU cores) can become a bottleneck in high-throughput scenarios. This is a key reason why high-performance databases like \u003Cstrong>SingleStore\u003C/strong> and \u003Cstrong>InfluxDB\u003C/strong> have moved away from mmap, citing issues with I/O spikes and contention.\u003C/p>\n\u003Ch2 id=\"conclusion-when-to-use-mmap\">Conclusion: When to Use mmap\u003C/h2>\n\u003Cp>mmap is a powerful, specialized tool. It’s a good choice when:\u003C/p>\n\u003Cul>\n\u003Cli>You have large files and need random access.\u003C/li>\n\u003Cli>Multiple processes need to read the same file, as they can share the same physical memory pages.\u003C/li>\n\u003Cli>Your workload is read-only and the data fits comfortably in RAM.\u003C/li>\n\u003C/ul>\n\u003Cp>It’s probably \u003Cem>not\u003C/em> the right choice when:\u003C/p>\n\u003Cul>\n\u003Cli>You need strict transactional safety, as in a database.\u003C/li>\n\u003Cli>You require the highest possible throughput on fast SSDs.\u003C/li>\n\u003Cli>You cannot tolerate the risk of unpredictable crashes due to I/O errors.\u003C/li>\n\u003C/ul>\n\u003Cp>mmap offers a fascinating look into the abstractions that operating systems provide. It blurs the line between files and memory, but like any powerful tool, it requires a deep understanding of its underlying mechanics to be used effectively.\u003C/p>\n\u003Ch2 id=\"references\">References\u003C/h2>\n\u003Cul>\n\u003Cli>A good wrapper for the mmap written in Go \u003Ca href=\"https://labix.org/gommap\">here.\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://github.com/buildbarn/bb-storage/blob/c346ca331930f1bc5e4f9bde75de96ee3e6c8a9c/pkg/blockdevice/memory_mapped_block_device_unix.go#L49\">This\u003C/a> is a piece of open-source Go code that uses a page-fault handler to deal with any IO error that may arise from memory mapping. The Debug packages \u003Ccode>SetPanicOnFault\u003C/code> function is used.\u003C/li>\n\u003Cli>I’m still reading this paper by Andy Pavlo &#x26; other researchers on reasons to avoid MMap in your DBMS check it out \u003Ca href=\"https://www.youtube.com/watch?v=1BRGU_AS25c\">Youtube\u003C/a> and \u003Ca href=\"https://www.cidrdb.org/cidr2022/papers/p13-crotty.pdf\">Paper.\u003C/a>\u003C/li>\n\u003C/ul>",{"headings":33,"localImagePaths":63,"remoteImagePaths":64,"frontmatter":65,"imagePaths":68},[34,38,42,45,48,51,54,57,60],{"depth":35,"slug":36,"text":37},2,"the-core-concept-how-it-works","The Core Concept: How It Works",{"depth":39,"slug":40,"text":41},3,"code-comparison-standard-io-vs-mmap","Code Comparison: Standard I/O vs. mmap",{"depth":35,"slug":43,"text":44},"the-advantage-zero-copy-io","The Advantage: Zero-Copy I/O",{"depth":35,"slug":46,"text":47},"the-hidden-perils","The Hidden Perils",{"depth":39,"slug":49,"text":50},"1-the-illusion-of-memory-and-io-stalls","1. The Illusion of Memory and I/O Stalls",{"depth":39,"slug":52,"text":53},"2-the-danger-of-sigbus-and-difficult-error-handling","2. The Danger of SIGBUS and Difficult Error Handling",{"depth":39,"slug":55,"text":56},"3-performance-on-fast-drives-nvme","3. Performance on Fast Drives (NVMe)",{"depth":35,"slug":58,"text":59},"conclusion-when-to-use-mmap","Conclusion: When to Use mmap",{"depth":35,"slug":61,"text":62},"references","References",[26,27,28],[],{"title":14,"description":15,"author":16,"publishDate":66,"tags":67},["Date","2025-12-10T00:00:00.000Z"],[19,20,21,22],[26,27,28],"a-developer-guide-to-mmap.md","hello-world",{"id":70,"data":72,"body":80,"filePath":81,"digest":82,"rendered":83,"legacyId":94},{"title":73,"description":74,"author":16,"publishDate":75,"tags":76},"Hello, World!","This is my first blog post.",["Date","2025-11-18T00:00:00.000Z"],[77,78,79],"astro","blogging","hello worlds","## Hello, World!\n\nThis is my first blog post using Astro's content collections. I'm excited to start writing and sharing my thoughts with you.","src/content/blog/hello-world.md","d3ed876049964506",{"html":84,"metadata":85},"\u003Ch2 id=\"hello-world\">Hello, World!\u003C/h2>\n\u003Cp>This is my first blog post using Astro’s content collections. I’m excited to start writing and sharing my thoughts with you.\u003C/p>",{"headings":86,"localImagePaths":88,"remoteImagePaths":89,"frontmatter":90,"imagePaths":93},[87],{"depth":35,"slug":70,"text":73},[],[],{"title":73,"description":74,"author":16,"publishDate":91,"tags":92},["Date","2025-11-18T00:00:00.000Z"],[77,78,79],[],"hello-world.md","til",["Map",97,98],"first-til",{"id":97,"data":99,"body":105,"filePath":106,"digest":107,"rendered":108,"legacyId":121},{"title":100,"description":101,"author":102,"publishDate":103,"tags":104},"My First TIL","This is my first TIL post!","Your Name",["Date","2025-12-10T00:00:00.000Z"],[77,95],"## My First TIL Post\n\nThis is the content of my first TIL post. I learned something new today!","src/content/til/first-til.md","a03a9ba3e104ded0",{"html":109,"metadata":110},"\u003Ch2 id=\"my-first-til-post\">My First TIL Post\u003C/h2>\n\u003Cp>This is the content of my first TIL post. I learned something new today!\u003C/p>",{"headings":111,"localImagePaths":115,"remoteImagePaths":116,"frontmatter":117,"imagePaths":120},[112],{"depth":35,"slug":113,"text":114},"my-first-til-post","My First TIL Post",[],[],{"title":100,"description":101,"author":102,"publishDate":118,"tags":119},["Date","2025-12-10T00:00:00.000Z"],[77,95],[],"first-til.md"]